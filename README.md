### GO Language:

- compiler based
- executables are different for diff OS
- this is not a VM based language unlike java which gives OS platform independence due to JVM

---

### Check if golang is installed

```bash
go version

```

---

### Golang Tools

- checking path variable

```bash
go env GOPATH
```

---

### Lexer in golang and types

- basically used for lexical analysis which is checking of the syntax

---

### Data types in Golang

1. Integer Types:

```go
var num int = 10
var num8 int8 = 127
var num16 int16 = 32767
var num32 int32 = 2147483647
var num64 int64 = 9223372036854775807

```

2. Floating Point Types:

```go
var float32Num float32 = 3.14
var float64Num float64 = 3.141592653589793

```

3. Boolean Type:

```go
var isTrue bool = true

```

4. string type

```go
var str string = "Hello, World!"
```

5. Array and Slice Types:

```go
var arr [3]int = [3]int{1, 2, 3}
var slice []int = []int{1, 2, 3}
```

6. Map Type:

```go
var keyValue map[string]int = map[string]int{"a": 1, "b": 2}
```

7. Struct Type:

```go
type Person struct {
    Name string
    Age  int
}

var person1 Person = Person{Name: "Alice", Age: 30}

```

8. Pointer Type:

```go
var ptr *int = &num
```

9. Interface Type:

```go
type Shape interface {
    Area() float64
}

// Example of implementing the interface:
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

var shape Shape = Circle{Radius: 5.0}

```

:warning: there is no list and set type in go lang

---

### := Operator

- In Go, the := operator is used for variable declaration and initialization in a concise way. It is shorthand for declaring and initializing variables without explicitly specifying the type.

```go
func main() {
    // Using :=
    a := 10
    b := "Hello, World!"
    c := 3.14
    d := true
}
```

---

### Modules in golang

:zap: A module is a collection of Go packages stored in a file tree with a go.mod file at its root. The go.mod file defines the module’s module path, which is also the import path used for the root directory, and its dependency requirements, which are the other modules needed for a successful build. Each dependency requirement is written as a module path and a specific semantic version.

---

### Packages in GoLang

1. Every Go source file begins with a package declaration to indicate which package the file belongs to.
2. Importing Packages:

```go
import (
    "fmt"
    "path/to/your/package/mathutils"
)
```

3. Exported Names

```go
func main() {
    result := mathutils.Add(1, 2)
    fmt.Println(result) // Outputs: 3
}
```

:zap: In Go, a name is exported (i.e., accessible from other packages) if it begins with a capital letter. For example, Add is exported from the mathutils package and can be used in other packages, whereas a function named add would not be accessible outside its own package.

4. `Initializing a Module`

```bash
go mod init myproject

```

5. `Managing Dependencies`
   When you import a package from a remote module, Go will automatically add it to your go.mod file. You can also add dependencies manually using go get.

```bash
go get github.com/some/dependency

go get github.com/go-sql-driver/mysql

```

6. go.mod: This file is generated by running go mod init myproject and might look like this:

```go
module myproject

go 1.18

```

---

### Arrays vs Slices in go lang

`Arrays`:

1. Fixed Size:
2. Memory Allocation: Arrays allocate a contiguous block of memory for all elements.

`Slices`:

1. Dynamic Size: can grow and shrink as needed.
2. Underlying Array: A slice is a descriptor of an array segment. It contains a pointer to the array, the length of the segment, and its capacity.

---

### Map Internals golang

```go
func main() {
    // Creating a map
    m := make(map[string]int)

    // Adding key-value pairs
    m["apple"] = 5
    m["banana"] = 3

    // Accessing values
    fmt.Println(m["apple"])  // Output: 5

    // Checking if a key exists
    value, ok := m["banana"]
    if ok {
        fmt.Println(value)  // Output: 3
    }

    // Deleting a key
    delete(m, "apple")
}
```

`Internals of Go Maps`

1. Structure of a Map : Internally, a map in Go is represented by a hmap struct. Here's a simplified version of how it might look:

:zap: Growth and Rehashing
When the load factor of the map (number of elements divided by the number of buckets) exceeds a certain threshold, Go grows the map by doubling the number of buckets (B is incremented by 1). This involves rehashing all existing keys into the new buckets, a process known as rehashing or evacuation.

- The growth happens incrementally to avoid long pauses. During this process, both the old and new bucket arrays might be active, and new keys are added to the new buckets while old keys are gradually moved.

- Hashing and Indexing
  When you add or look up a key in a map, Go hashes the key to determine which bucket it belongs to. The hash function used is designed to distribute keys uniformly across the buckets to minimize collisions.

`Hash the Key`: Compute the hash of the key.
Determine Bucket: Use the lower bits of the hash to determine the index of the bucket (bucket index = hash % number of buckets).
Top Hash: Use the top bits of the hash to compare with the tophash array in the bucket for quick rejection of non-matching keys.

---

### Comma Error Syntax

---

### Conversions in golang

```go
 // Explicit conversion from int to float64
    var x int = 42
    var y float64 = float64(x)
```

```go
// Explicit conversion from float64 to int
    var z float64 = 3.14
    var w int = int(z)
```

```go
 // Convert string to int
    str := "123"
    num, err := strconv.Atoi(str)
```

```go
 // Convert int to string
    num := 123
    str := strconv.Itoa(num)
```

---

### Memory Management in Golang

- Memory management in Go is handled by the Go runtime, which includes an automatic garbage collector (GC).
- The garbage collector manages memory allocation and deallocation for objects that are no longer in use.

1. `Automatic Garbage Collection (GC)`: Go has a built-in garbage collector that periodically scans the memory to find and reclaim unused objects.

2. `Heap Allocation`: Go uses a heap-based memory allocation model. Objects created using the new() function or composite literals are allocated on the heap. The Go runtime manages the allocation and deallocation of memory on the heap.

3. `Stack Allocation:` Go uses a stack-based allocation for local variables and function call frames. Stack allocation is fast and efficient because it doesn't require garbage collection. However, the size of the stack is fixed, so large objects or objects that outlive the function call may be allocated on the heap instead.

4. `Escape Analysis:` Variables that do not escape the function's scope can be allocated on the stack, while those that escape are allocated on the heap.

5. `Slices and Maps`: Slices and maps in Go are reference types, meaning they are lightweight and passed by reference

6. `Memory Profiling:` Go provides tools for memory profiling, such as the runtime/pprof package and the go tool pprof command. These tools allow developers to analyze memory usage and identify memory leaks or performance bottlenecks in their programs.

---

### Pointers in golang

---

### Defer

- LIFO Last in first out

---

### Wait Group

- just like join in java

```go
func main() {
    var wg sync.WaitGroup

    numWorkers := 5

    for i := 1; i <= numWorkers; i++ {
        wg.Add(1) // Increments the WaitGroup counter for each goroutine spawned
        go worker(i, &wg)
    }

    // Wait for all workers to finish
    wg.Wait()

    fmt.Println("All workers done")
}

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // Decrements the WaitGroup counter when the goroutine completes

    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second) // Simulate some work
    fmt.Printf("Worker %d done\n", id)
}

```

---

### Memory Allocation and Scope

As for memory allocation, variables in Go are allocated memory based on their scope and lifetime.

- Global variables are allocated memory when the program starts and are retained throughout the entire execution of the program.
- Function-level variables are allocated memory when the function is called and deallocated when the function exits.

- block level variables are allocated memory when the block is entered and deallocated when the block exits. Go's garbage collector manages memory allocation and deallocation for variables with dynamic lifetime.

---

### Mux

- `Add Mux`:

```bash
go get -u github.com/gorilla/mux
```

---

Need of Go Language:

- Java complex type system
- Python not quick

- Choice b/w rapid development and performance
- Ruby/Python – slow but faster development
- C++ - Faster perfomance slower development

- Compilation times in C++ is slower.
- Go has lightning quick compilation times

- Dynamic data type languages – python,javascript
- Static data type languages => C++, java,GO

GO Features:

1. Development speed/Compilation Speed
2. Concurrency

Go runtime => automatically schedules Go routines => Go Logical processor => each logical processor is bound to single OS Thread.

Main Package:
init () function is called prior to main()

// main is the entry point for the program.

You can see the function main is located in a package called main. If your main func-
tion doesn’t exist in package main, the build tools won’t produce an executable.

The blank identifier allows the compiler to accept the import and call any init
functions that can be found in the different code files within that package. For our
program, this is required because the rss.go code file in the matchers package con-
tains an init function to register the RSS matcher for use. We’ll come back to how all
this works later.

GO:
Strong and statically type language
fast compile type
garbage collected language
built in concurrency

Installing on linux:
sudo mv go /usr/local

which go

In java we need complete jdk and most of the things are in that jdk, like packages and all.
But in other languages like python,node,go we use a client to install stuff, pip in python, npm in node , go in go lang.

We can return multiple values in go lang.

Variable Scope:
Java uses function scoping.

Access Modifier for method:
Use the first letter capital of the function to use it outside the package.\

Arrays and slices:

Building microservices with GO:

Yet, despite this and many other optimization efforts, the time needed to build certain systems reached several dozen minutes in 2007. Given the enormous scale, developing software was a slow and difficult process. Code compilation (mainly in C++) lasted too long. On the other hand, using threads and memory sharing in C++ and Java to write concurrent code was too complicated. Programmers made a lot of mistakes, and the code was often not optimized. To use concurrent programming, a programmer had to create many threads that shared memory of the same process. If there were too many operations waiting for external resources (disk, network, etc.), as was often the case in a typical network application, a thread was left waiting—and gobbling up resources like RAM and CPUs (for context switching). If a server was processing 10,000 parallel connections, the program became very resource-hungry.
To solve this problem, alternative models of concurrent programming were created. An asynchronous model used especially in Node.js is one of them. In this model, when a function is about to perform an I/O operation, it does not block thread, thus making the entire process more effective. Still, it is more complex for programmers to use and much more difficult to debug.

Programs written in Go are executed fast and use little RAM. When Go code is compiled, an executable file is created. This is not a bytecode or any other intermediary code, but a machine code.

Programmers don’t have to worry about memory management. Golang has a built-in garbage collector which removes from the memory instances that are no longer being used. Additionally, the Go compiler uses escape analysis algorithms to decide what memory type (stack or heap) should be allocated to a given structure. A programmer does not have to worry about it. This feature makes programming much easier, while at the same time boosting software performance considerably.

REST API IN GO:

Installing go:

Download go:
https://go.dev/dl/

Install:
sudo tar -xvf go.tar.gz -C /usr/local

Go Path:
$HOME/go

Memory Management in GO Lang:
